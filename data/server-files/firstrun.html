<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BLIP Dashboard Repair</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #020617;
      color: #e2e8f0;
    }
    main {
      width: min(420px, 100%);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 14px;
      padding: 20px;
      background: rgba(15, 23, 42, 0.9);
      box-shadow: 0 8px 30px rgba(2, 6, 23, 0.5);
    }
    h1 {
      margin: 0 0 10px;
      font-size: 1.2rem;
      text-align: center;
    }
    .status {
      margin: 0 0 12px;
      padding: 12px;
      border-radius: 10px;
      background: rgba(16, 185, 129, 0.12);
      border: 1px solid rgba(45, 212, 191, 0.35);
      min-height: 48px;
      line-height: 1.4;
    }
    .status.error {
      background: rgba(239, 68, 68, 0.12);
      border-color: rgba(248, 113, 113, 0.45);
    }
    pre {
      margin: 0;
      padding: 12px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px dashed rgba(148, 163, 184, 0.4);
      max-height: 220px;
      overflow: auto;
      font-size: 0.8rem;
      white-space: pre-wrap;
    }
    small {
      display: block;
      margin-top: 10px;
      opacity: 0.7;
      font-size: 0.75rem;
      text-align: center;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <main>
    <h1>Repairing your BLIP</h1>
    <div class="status" id="status">Waiting to start…</div>
    <pre id="log"></pre>
    <small>This helper runs entirely on your prop. Keep this tab open until it redirects.</small>
  </main>
  <script>
    (() => {
      const MANIFEST_URL = "https://www.goldengeek.org/blip/download/server/latest.php";
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");
      const params = new URLSearchParams(window.location.search);
      const deviceParam = params.get("device") || "";
      const defaultDevice = `${window.location.protocol}//${window.location.host}`;
      const HTTP_FALLBACK_KEY = "blip:firstrun:httpFallback";
      const log = (msg) => {
        logEl.textContent += msg + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      };
      const setStatus = (msg, err = false) => {
        statusEl.textContent = msg;
        statusEl.classList.toggle("error", err);
        log(msg);
      };
      const readFallbackFlag = () => {
        try {
          return sessionStorage.getItem(HTTP_FALLBACK_KEY) === "1";
        } catch (err) {
          return false;
        }
      };
      const markFallbackTried = () => {
        try {
          sessionStorage.setItem(HTTP_FALLBACK_KEY, "1");
        } catch (err) {}
      };
      const clearFallbackFlag = () => {
        try {
          sessionStorage.removeItem(HTTP_FALLBACK_KEY);
        } catch (err) {}
      };
      const normalizeDevice = (raw) => {
        const trimmed = raw.trim();
        if (!trimmed) {
          return "";
        }
        const decoded = decodeURIComponent(trimmed);
        const sanitized = decoded.replace(/\s+/g, "").replace(/\/+$/, "");
        return /^https?:\/\//i.test(sanitized) ? sanitized : `http://${sanitized}`;
      };
      const deviceBase = normalizeDevice(deviceParam || defaultDevice);
      if (!deviceBase) {
        setStatus("Missing ?device= parameter. Reboot your prop and try again.", true);
        return;
      }
      const forceHttpReload = (httpUrl) => {
        setStatus("Browser upgraded us to HTTPS. Reloading over HTTP so uploads succeed…");
        log(`HTTP link: ${httpUrl}`);
        setTimeout(() => {
          try {
            window.location.replace(httpUrl);
          } catch (err) {
            console.warn("Reload failed", err);
          }
        }, 800);
      };
      const fetchJson = (url) => fetch(url, { cache: "no-cache" }).then((resp) => {
        if (!resp.ok) {
          throw new Error(`Request failed (${resp.status})`);
        }
        return resp.json();
      });
      const ensureJSZip = () => {
        if (window.JSZip) {
          return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
          s.onload = resolve;
          s.onerror = () => reject(new Error("Unable to load JSZip"));
          document.head.appendChild(s);
        });
      };
      const upload = async (blob, name) => {
        const target = new URL(deviceBase + "/uploadFile");
        target.searchParams.set("folder", "/server");
        const body = new FormData();
        body.append("uploadData", blob, name);
        const resp = await fetch(target.toString(), { method: "POST", body });
        if (!resp.ok) {
          const txt = await resp.text().catch(() => "");
          throw new Error(`Upload failed (${resp.status}) ${txt}`.trim());
        }
      };
      const run = async () => {
        try {
          const needsHttp = window.location.protocol === "https:" && deviceBase.startsWith("http://");
          const httpUrl = window.location.href.replace(/^https:/i, "http:");
          if (needsHttp) {
            if (readFallbackFlag()) {
              setStatus("Browser still forces HTTPS. Open the HTTP link below manually to continue.", true);
              log(`HTTP link: ${httpUrl}`);
              log("If it changes back to https, type http:// yourself before the domain.");
              return;
            }
            markFallbackTried();
            forceHttpReload(httpUrl);
            return;
          }
          clearFallbackFlag();
          setStatus("Downloading manifest…");
          await ensureJSZip();
          const manifest = await fetchJson(MANIFEST_URL);
          if (!manifest.url) {
            throw new Error("Manifest response did not include a download URL");
          }
          setStatus("Downloading dashboard bundle…");
          const zipResp = await fetch(manifest.url, { cache: "no-cache" });
          if (!zipResp.ok) {
            throw new Error(`Download failed (${zipResp.status})`);
          }
          const zipData = await zipResp.arrayBuffer();
          const zip = await JSZip.loadAsync(zipData);
          const entries = Object.values(zip.files).filter((f) => !f.dir);
          if (!entries.length) {
            throw new Error("Bundle did not contain any files");
          }
          let uploaded = 0;
          for (const entry of entries) {
            uploaded += 1;
            setStatus(`Uploading ${entry.name} (${uploaded}/${entries.length})…`);
            const blob = await entry.async("blob");
            await upload(blob, entry.name.split("/").pop());
          }
          setStatus("All files uploaded. Opening /edit…");
          setTimeout(() => {
            const redirect = deviceBase.replace(/\/+$/, "") + "/edit";
            window.location.href = redirect;
          }, 800);
        } catch (err) {
          console.error(err);
          setStatus(`Setup failed: ${err && err.message ? err.message : err}`, true);
          log("Retry after rebooting the prop if needed.");
        }
      };
      run();
    })();
  </script>
</body>
</html>
