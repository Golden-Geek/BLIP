<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>BLIP Control Panel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="color-scheme" content="dark" />
  <script src="osc-mini.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root {
      --bg: #0f172a;
      --card-bg: #020617;
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.15);
      --accent-strong: #16a34a;
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --border: #1f2937;
      --danger: #ef4444;
      --danger-soft: rgba(239, 68, 68, 0.18);
      --warning: #f59e0b;
      --muted: #374151;
      --radius-xl: 18px;
      --radius-lg: 999px;
      --shadow-soft: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 48%, #000 100%);
      color: var(--text-main);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 16px;
    }

    .shell {
      width: 100%;
      max-width: 1120px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .card {
      background: radial-gradient(circle at top left, #111827 0, #020617 50%);
      border-radius: 24px;
      padding: 20px 18px 18px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: var(--shadow-soft);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 10% 0%, rgba(56, 189, 248, 0.08) 0, transparent 60%),
        radial-gradient(circle at 90% 0%, rgba(34, 197, 94, 0.12) 0, transparent 55%);
      opacity: 0.9;
      pointer-events: none;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .header-row {
      display: flex;
      align-items: center;
      gap: 14px;
      margin-bottom: 10px;
    }

    .chip {
      width: 36px;
      height: 36px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 30% 0, #22c55e33 0, #020617 70%);
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.8),
        0 10px 25px rgba(0, 0, 0, 0.65);
    }

    .chip svg {
      width: 22px;
      height: 22px;
    }

    .title-block {
      flex: 1;
    }

    h1.title {
      font-size: 1.4rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      margin: 0 0 2px;
    }

    .subtitle {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    .badge {
      font-size: 0.7rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(52, 211, 153, 0.45);
      color: #bbf7d0;
      background: radial-gradient(circle at 0 0, #22c55e33 0, transparent 65%);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 500;
      white-space: nowrap;
    }

    .controls-row {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .btn {
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 0.8rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.08s ease-out, transform 0.08s ease-out,
        box-shadow 0.08s ease-out;
    }

    .btn-primary {
      border-color: rgba(34, 197, 94, 0.9);
      background: linear-gradient(135deg, var(--accent-strong), var(--accent));
      color: #022c22;
      box-shadow:
        0 0 0 1px rgba(16, 185, 129, 0.95),
        0 12px 26px rgba(16, 185, 129, 0.45);
    }

    .btn-danger {
      border-color: rgba(248, 113, 113, 0.9);
      background: radial-gradient(circle at 0 0, #ef44441f 0, #111827 70%);
      color: #fecaca;
    }

    .btn:hover {
      transform: translateY(-0.5px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.45);
    }

    .btn:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 5px 14px rgba(0, 0, 0, 0.5);
    }

    .toggle-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    .toggle-label {
      font-size: 0.8rem;
    }

    .toggle {
      position: relative;
      width: 42px;
      height: 22px;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background-color: #111827;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      transition: 0.15s;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      top: 2px;
      border-radius: 999px;
      background-color: #9ca3af;
      transition: 0.15s;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
    }

    .toggle input:checked+.slider {
      background-color: rgba(34, 197, 94, 0.18);
      border-color: rgba(34, 197, 94, 0.95);
    }

    .toggle input:checked+.slider:before {
      transform: translateX(18px);
      background-color: #bbf7d0;
    }

    /* OTA uploader card */
    .section-title {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-soft);
      margin-bottom: 8px;
    }

    .file-row {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr);
      gap: 10px;
      align-items: center;
    }

    .file-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.55);
      background: rgba(15, 23, 42, 0.9);
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--text-soft);
    }

    .file-label span.icon {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.15);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
    }

    .file-label span.text-strong {
      color: var(--text-main);
      font-weight: 500;
    }

    #firmware {
      display: none;
    }

    .file-meta {
      font-size: 0.78rem;
      color: var(--text-soft);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 4px;
    }

    .file-pill {
      padding: 4px 9px;
      border-radius: 999px;
      background: rgba(30, 64, 175, 0.28);
      border: 1px solid rgba(129, 140, 248, 0.8);
      font-size: 0.72rem;
      color: #e0e7ff;
    }

    .file-pill.muted {
      background: rgba(31, 41, 55, 0.8);
      border-color: rgba(75, 85, 99, 0.9);
      color: #9ca3af;
    }

    .file-pill.warn {
      background: var(--danger-soft);
      border-color: var(--danger);
      color: #fecaca;
    }

    .progress-wrapper {
      margin-top: 14px;
    }

    .progress-bar {
      height: 9px;
      border-radius: var(--radius-lg);
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(31, 41, 55, 0.95);
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      position: absolute;
      inset: 0;
      transform-origin: left center;
      transform: scaleX(0);
      background: linear-gradient(90deg,
          var(--accent),
          var(--accent-strong),
          #22c55e);
      transition: transform 0.18s ease-out;
    }

    .progress-text {
      margin-top: 4px;
      font-size: 0.75rem;
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .progress-text span.value {
      color: #bbf7d0;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }

    .footer-row {
      margin-top: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .status {
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .status strong {
      font-weight: 600;
    }

    .status.ok strong {
      color: #bbf7d0;
    }

    .status.error strong {
      color: #fecaca;
    }

    .status.warn strong {
      color: #fed7aa;
    }

    .btn-upload {
      padding: 8px 18px;
      border-radius: var(--radius-lg);
      border: none;
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(135deg, var(--accent-strong), var(--accent));
      color: #022c22;
      box-shadow:
        0 0 0 1px rgba(16, 185, 129, 0.95),
        0 12px 30px rgba(16, 185, 129, 0.45);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
        opacity 0.1s ease-out, filter 0.1s ease-out;
    }

    .btn-upload:disabled {
      cursor: default;
      opacity: 0.35;
      box-shadow: 0 0 0 1px rgba(55, 65, 81, 0.9);
      background: linear-gradient(135deg, #4b5563, #374151);
      color: #d1d5db;
      filter: grayscale(0.2);
    }

    .btn-upload:not(:disabled):active {
      transform: translateY(1px) scale(0.99);
      box-shadow:
        0 0 0 1px rgba(16, 185, 129, 0.95),
        0 6px 18px rgba(16, 185, 129, 0.4);
    }

    .btn-upload .spinner {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 2px solid rgba(6, 78, 59, 0.3);
      border-top-color: #022c22;
      animation: spin 0.7s linear infinite;
    }

    .hint-row {
      margin-top: 8px;
      font-size: 0.75rem;
      color: var(--text-soft);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .hint-pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.9);
      font-size: 0.72rem;
      color: #9ca3af;
    }

    .firmware-status {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: radial-gradient(circle at 10% 0%, rgba(56, 189, 248, 0.05) 0, rgba(15, 23, 42, 0.9) 65%);
      margin-bottom: 12px;
    }

    .firmware-status>div {
      flex: 1;
      min-width: 140px;
    }

    .firmware-label {
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .firmware-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-main);
    }

    .status-pill {
      align-self: center;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-soft);
      white-space: nowrap;
    }

    .status-pill.ok {
      border-color: rgba(34, 197, 94, 0.8);
      color: #86efac;
      background: rgba(34, 197, 94, 0.1);
    }

    .status-pill.warn {
      border-color: rgba(245, 158, 11, 0.8);
      color: #fcd34d;
      background: rgba(245, 158, 11, 0.12);
    }

    .status-pill.error {
      border-color: rgba(239, 68, 68, 0.8);
      color: #fecaca;
      background: rgba(239, 68, 68, 0.12);
    }

    .status-helper {
      font-size: 0.78rem;
      color: var(--text-soft);
      margin-bottom: 12px;
    }

    .firmware-download {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 8px;
      align-items: center;
    }

    .firmware-download select {
      flex: 1;
      min-width: 160px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 0.85rem;
    }

    .btn-download {
      padding: 8px 16px;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(34, 197, 94, 0.8);
      background: linear-gradient(135deg, var(--accent-strong), var(--accent));
      color: #022c22;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(16, 185, 129, 0.95),
        0 12px 26px rgba(16, 185, 129, 0.45);
    }

    .btn-download:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      box-shadow: none;
      background: rgba(15, 23, 42, 0.6);
      color: rgba(226, 232, 240, 0.6);
      border-color: rgba(75, 85, 99, 0.9);
    }

    .firmware-download .btn-download {
      flex: 0;
    }

    .firmware-auto {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 12px;
      align-items: center;
    }

    .firmware-auto .btn-download {
      flex: 1;
      justify-content: center;
    }

    .download-status {
      font-size: 0.75rem;
      color: var(--text-soft);
      margin-bottom: 14px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Editor / parameters styling */
    .editor-card .section-title {
      margin-bottom: 6px;
    }

    #editor {
      margin-top: 6px;
      max-height: calc(100vh - 260px);
      overflow-y: auto;
      padding-right: 4px;
    }

    #editor::-webkit-scrollbar {
      width: 6px;
    }

    #editor::-webkit-scrollbar-track {
      background: transparent;
    }

    #editor::-webkit-scrollbar-thumb {
      background: rgba(55, 65, 81, 0.9);
      border-radius: 999px;
    }

    .component {
      width: auto;
      margin: 2px 0;
      padding: 6px 8px 8px;
      background-color: rgba(15, 23, 42, 0.9);
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
      position: relative;
    }

    .component.level0 {
      margin: 8px 0;
      background: radial-gradient(circle at top left, #0f172a, #020617 60%);
    }

    .components {
      display: block;
      margin: 0;
    }

    .component.level0>.components {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(17rem, 1fr));
      grid-gap: 0.5rem;
      margin: 4px 0 0;
      padding: 2px;
    }

    p.title {
      font-size: 0.9rem;
      margin: 0 0 4px;
      font-weight: 600;
      color: rgba(248, 250, 252, 0.9);
      text-align: left;
    }

    .parameters {
      margin-top: 2px;
    }

    .parameter {
      margin: 4px 0;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 4px;
      position: relative;
    }

    .parameter label {
      min-width: 9em;
      color: var(--text-soft);
    }

    .parameter input,
    .parameter select {
      font-family: inherit;
      font-size: 0.8rem;
      border-radius: 6px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      padding: 4px 6px;
      background-color: #020617;
      color: var(--text-main);
    }

    .parameter input[type="button"] {
      border-radius: 999px;
      padding-inline: 10px;
      text-transform: none;
      border-color: rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at 0 0, #22c55e22 0, #020617 60%);
      cursor: pointer;
    }

    .parameter input[type="button"]:hover {
      background: radial-gradient(circle at 0 0, #22c55e33 0, #020617 60%);
    }

    .parameter input[type="checkbox"],
    .parameter input[type="range"] {
      accent-color: limegreen;
      width: auto;
    }

    .parameter input[type="checkbox"]:disabled {
      accent-color: lightblue;
    }

    .parameter input:disabled {
      color: lightblue;
      opacity: 0.7;
    }

    .parameter input[type="text"],
    .parameter input[type="number"] {
      max-width: 8.6em;
    }

    .parameter input[type="range"] {
      max-width: 5.5em;
    }

    .sliderText {
      max-width: 2.8em !important;
    }

    /* Logger Panel */
    .logger-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: var(--accent);
      color: #022c22;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(34, 197, 94, 0.4);
      transition: all 0.2s ease;
    }

    .logger-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 24px rgba(34, 197, 94, 0.6);
    }

    .logger-toggle svg {
      width: 24px;
      height: 24px;
    }

    .logger-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 400px;
      height: 100vh;
      background: var(--card-bg);
      border-left: 1px solid var(--border);
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
      z-index: 999;
      display: flex;
      flex-direction: column;
      transition: right 0.3s ease;
    }

    .logger-panel.open {
      right: 0;
    }

    .logger-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: radial-gradient(circle at top left, #111827 0, #020617 50%);
    }

    .logger-header h3 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-main);
    }

    .logger-close {
      background: none;
      border: none;
      color: var(--text-soft);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .logger-close:hover {
      background: var(--muted);
      color: var(--text-main);
    }

    .logger-close svg {
      width: 20px;
      height: 20px;
    }

    .logger-controls {
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .logger-controls .btn {
      padding: 4px 10px;
      font-size: 0.75rem;
    }

    .logger-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.75rem;
      line-height: 1.4;
    }

    .log-entry {
      padding: 6px 8px;
      margin-bottom: 4px;
      border-radius: 4px;
      border-left: 3px solid var(--muted);
      background: rgba(15, 23, 42, 0.5);
      word-wrap: break-word;
    }

    .log-entry.info {
      border-left-color: #3b82f6;
      background: rgba(59, 130, 246, 0.1);
    }

    .log-entry.warning {
      border-left-color: var(--warning);
      background: rgba(245, 158, 11, 0.1);
    }

    .log-entry.error {
      border-left-color: var(--danger);
      background: rgba(239, 68, 68, 0.1);
    }

    .log-time {
      color: var(--text-soft);
      font-size: 0.7rem;
      margin-right: 6px;
    }

    .log-source {
      color: var(--accent);
      font-weight: 600;
      margin-right: 6px;
    }

    .log-message {
      color: var(--text-main);
    }

    .logger-content::-webkit-scrollbar {
      width: 8px;
    }

    .logger-content::-webkit-scrollbar-track {
      background: var(--bg);
    }

    .logger-content::-webkit-scrollbar-thumb {
      background: var(--muted);
      border-radius: 4px;
    }

    .logger-content::-webkit-scrollbar-thumb:hover {
      background: var(--border);
    }

    .sliderText {
      max-width: 2.8em !important;
      vertical-align: bottom;
      margin-left: 10px;
    }

    .parameter.enable-param {
      position: absolute;
      left: 8px;
      top: 6px;
    }

    .parameter.enable-param label {
      display: none;
    }

    .parameter.enable-param input[type="checkbox"] {
      accent-color: antiquewhite;
    }

    @media (min-width: 960px) {
      .card {
        padding: 22px 22px 20px;
      }
    }

    @media (max-width: 720px) {
      .controls-row {
        align-items: flex-start;
      }

      .btn-group {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="shell">
    <!-- Top controls -->
    <div class="card">
      <div class="card-inner">
        <div class="header-row">
          <div class="chip" aria-hidden="true">
            <svg viewBox="0 0 24 24" fill="none">
              <rect x="4" y="4" width="16" height="16" rx="3" stroke="rgba(148,163,184,0.75)" stroke-width="1.4" />
              <rect x="8" y="8" width="8" height="8" rx="1.6" stroke="#22c55e" stroke-width="1.4" />
              <circle cx="12" cy="12" r="1.4" fill="#22c55e" />
            </svg>
          </div>
          <div class="title-block">
            <h1 class="title">BLIP Control Panel</h1>
            <p class="subtitle">
              Live settings, OSC control and firmware updates ‚Äî without touching your stored config.
            </p>
          </div>
          <div class="badge">Online</div>
        </div>

        <div class="controls-row">
          <div class="btn-group">
            <button type="button" class="btn btn-primary" onclick="sendCommand('/settings/save'); restartDevice();">
              Save &amp; Restart
            </button>
            <button type="button" class="btn" onclick="sendCommand('/settings/save');">
              Save Settings
            </button>
            <button type="button" class="btn" onclick="restartDevice();">
              Restart
            </button>
            <button type="button" class="btn btn-danger" onclick="sendCommand('/shutdown');">
              Shutdown
            </button>
            <button type="button" class="btn" onclick="sendCommand('/settings/testMode');">
              Test Mode
            </button>
          </div>

          <div class="toggle-wrap">
            <span class="toggle-label">Show config</span>
            <label class="toggle">
              <input id="showConfig" type="checkbox" checked />
              <span class="slider"></span>
            </label>
          </div>
        </div>
      </div>
    </div>

    <!-- OTA firmware uploader -->
    <div class="card">
      <div class="card-inner">
        <div class="section-title">Firmware update</div>

        <div class="firmware-status" id="firmwareStatus">
          <div>
            <div class="firmware-label">Device firmware</div>
            <div class="firmware-value" id="currentFirmwareVersion">‚Äî</div>
          </div>
          <div>
            <div class="firmware-label">Latest available</div>
            <div class="firmware-value" id="latestFirmwareVersion">‚Äî</div>
          </div>
          <div class="status-pill" id="firmwareStatusPill">Checking‚Ä¶</div>
        </div>
        <div class="status-helper" id="firmwareStatusMessage">Checking firmware status‚Ä¶</div>
        <div class="firmware-download">
          <select id="firmwareVersionSelect" disabled>
            <option>Loading versions‚Ä¶</option>
          </select>
          <button class="btn-download" id="downloadFirmwareBtn" disabled>Download .zip</button>
        </div>
        <div class="download-status" id="downloadFirmwareStatus">Firmware download link activates once the device is matched to a catalog entry.</div>
        <div class="firmware-auto">
          <button class="btn-download" id="autoUpdateBtn" disabled>Download &amp; Install Latest</button>
        </div>
        <div class="download-status" id="autoUpdateStatus">Auto-update will enable when a newer firmware is available.</div>

        <div class="file-row">
          <label class="file-label" for="firmware">
            <span class="icon">üìÅ</span>
            <span>
              <span class="text-strong">Choose firmware</span>
              <span style="display:block;font-size:0.75rem;color:var(--text-soft);">
                ESP32 <code>.bin</code> built with your current partition table
              </span>
            </span>
          </label>
          <input type="file" id="firmware" accept=".bin" />
        </div>
        <div class="file-meta" id="fileMeta">
          <span class="file-pill muted">No file selected</span>
        </div>

        <div class="progress-wrapper">
          <div class="progress-bar" aria-hidden="true">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text">
            <span id="progressLabel">Waiting for upload‚Ä¶</span>
            <span class="value" id="progressValue">0%</span>
          </div>

          <div class="footer-row">
            <div class="status" id="statusText">
              <strong>Status:</strong> idle
            </div>
            <button class="btn-upload" id="uploadBtn" disabled>
              <span id="uploadBtnLabel">Upload firmware</span>
              <span id="uploadSpinner" class="spinner" style="display:none;"></span>
            </button>
          </div>

          <div class="hint-row">
            <span class="hint-pill">Tip</span>
            <span>Device will reboot automatically after a successful OTA flash.</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Editor / parameters -->
    <div class="card editor-card">
      <div class="card-inner">
        <div class="section-title">Live parameters</div>
        <div id="editor">Connecting‚Ä¶</div>
      </div>
    </div>
  </div>

  <!-- Logger Toggle Button -->
  <button class="logger-toggle" id="loggerToggle" title="Toggle Debug Logger">
    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
    </svg>
  </button>

  <!-- Logger Panel -->
  <div class="logger-panel" id="loggerPanel">
    <div class="logger-header">
      <h3>Debug Logger</h3>
      <button class="logger-close" id="loggerClose">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="logger-controls">
      <button class="btn btn-danger" id="clearLogs">Clear</button>
      <span style="flex: 1; font-size: 0.75rem; color: var(--text-soft);">
        <span id="logCount">0</span> entries
      </span>
    </div>
    <div class="logger-content" id="loggerContent">
      <div class="log-entry info">
        <span class="log-source">System</span>
        <span class="log-message">Logger ready. Waiting for messages...</span>
      </div>
    </div>
  </div>

  <script>
    // ==============================
    // Connection & configuration
    // ==============================
    const searchParams = new URLSearchParams(window.location.search);
    const urlIp = searchParams.get("ip");
    const local = window.location.hostname.startsWith("1") || window.location.hostname.includes(".local");
    const ip = urlIp || (local ? window.location.hostname : "192.168.1.115");
    let data = {};
    let oscWS;
    let connectAttempts = 0;

    const firmwareBaseUrl = "https://www.goldengeek.org/blip/download/firmware/getFirmwares.php";
    const firmwareListUrl = firmwareBaseUrl + "?list";
    let firmwareCatalog = null;
    let deviceInfo = null;
    let versionCheckStarted = false;
    let catalogMatchKey = null;
    let catalogMatchEntry = null;
    let pendingAutoVersion = null;
    let uploadInProgress = false;
    let autoUpdateInProgress = false;
    let uploadFirmwareBlob = null;

    const firmwareEls = {
      current: document.getElementById("currentFirmwareVersion"),
      latest: document.getElementById("latestFirmwareVersion"),
      pill: document.getElementById("firmwareStatusPill"),
      message: document.getElementById("firmwareStatusMessage"),
    };

    const firmwareDownloadEls = {
      select: document.getElementById("firmwareVersionSelect"),
      button: document.getElementById("downloadFirmwareBtn"),
      status: document.getElementById("downloadFirmwareStatus"),
    };

    const autoUpdateEls = {
      button: document.getElementById("autoUpdateBtn"),
      status: document.getElementById("autoUpdateStatus"),
    };

    if (firmwareDownloadEls.button) {
      firmwareDownloadEls.button.addEventListener("click", handleFirmwareDownload);
    }

    if (autoUpdateEls.button) {
      autoUpdateEls.button.addEventListener("click", handleAutoUpdate);
    }

    setAutoUpdateAvailability(null, "Auto-update will enable when a newer firmware is available.");

    setTimeout(() => {
      connectToServer();
      startVersionChecks();
    }, 100);

    function startVersionChecks() {
      if (versionCheckStarted) return;
      versionCheckStarted = true;
      setDownloadStatus("Matching device with firmware catalog‚Ä¶");
      setAutoUpdateAvailability(null, "Matching device with firmware catalog‚Ä¶");
      fetchDeviceHostInfo();
      fetchFirmwareCatalog();
    }

    function updateFirmwareStatusUI({ current, latest, state, message }) {
      if (current !== undefined && firmwareEls.current) {
        firmwareEls.current.textContent = current || "‚Äî";
      }

      if (latest !== undefined && firmwareEls.latest) {
        firmwareEls.latest.textContent = latest || "‚Äî";
      }

      if (state && firmwareEls.pill) {
        firmwareEls.pill.classList.remove("ok", "warn", "error");
        let pillText = "";
        switch (state) {
          case "ok":
            firmwareEls.pill.classList.add("ok");
            pillText = "Up to date";
            break;
          case "warn":
            firmwareEls.pill.classList.add("warn");
            pillText = "Update available";
            break;
          case "error":
            firmwareEls.pill.classList.add("error");
            pillText = "Unavailable";
            break;
          default:
            pillText = "Checking‚Ä¶";
            break;
        }
        firmwareEls.pill.textContent = pillText;
      }

      if (message !== undefined && firmwareEls.message) {
        firmwareEls.message.textContent = message;
      }
    }

    function fetchDeviceHostInfo() {
      updateFirmwareStatusUI({ state: "checking", message: "Reading firmware version from device‚Ä¶" });
      fetch("http://" + ip + "/?HOST_INFO=1", { cache: "no-cache" })
        .then((response) => {
          if (!response.ok) {
            throw new Error("HOST_INFO request failed with status " + response.status);
          }
          return response.json();
        })
        .then((info) => {
          deviceInfo = info || {};
          const detectedMsg = deviceInfo.NAME
            ? "Detected " + deviceInfo.NAME + ". Checking online catalog‚Ä¶"
            : "Checking online catalog‚Ä¶";
          updateFirmwareStatusUI({ current: deviceInfo.VERSION || "‚Äî", message: detectedMsg });
          evaluateFirmwareVersions();
        })
        .catch((err) => {
          console.warn("Failed to get HOST_INFO", err);
          updateFirmwareStatusUI({ state: "error", message: "Unable to read firmware version from device." });
          updateDownloadControls(null, null);
          setDownloadStatus("Unable to read device info; firmware downloads are disabled.");
          setAutoUpdateAvailability(null, "Unable to read device info; auto-update disabled.");
        });
    }

    function fetchFirmwareCatalog() {
      fetch(firmwareListUrl, { cache: "no-cache" })
        .then((response) => {
          if (!response.ok) {
            throw new Error("Firmware list request failed with status " + response.status);
          }
          return response.json();
        })
        .then((list) => {
          firmwareCatalog = list || {};
          evaluateFirmwareVersions();
        })
        .catch((err) => {
          console.warn("Failed to fetch firmware catalog", err);
          updateFirmwareStatusUI({ state: "error", message: "Unable to reach firmware download server." });
          updateDownloadControls(null, null);
          setDownloadStatus("Firmware download server unreachable.");
          setAutoUpdateAvailability(null, "Firmware download server unreachable.");
        });
    }

    function evaluateFirmwareVersions() {
      if (!deviceInfo) {
        return;
      }

      const currentVersion = deviceInfo.VERSION || "‚Äî";
      updateFirmwareStatusUI({ current: currentVersion });

      if (!firmwareCatalog) {
        updateFirmwareStatusUI({ state: "checking", message: "Waiting for firmware catalog‚Ä¶" });
        setDownloadStatus("Waiting for firmware catalog to load‚Ä¶");
        setAutoUpdateAvailability(null, "Waiting for firmware catalog to load‚Ä¶");
        return;
      }

      const match = findCatalogEntry(deviceInfo.NAME);
      const catalogEntry = match ? match.entry : null;
      if (!catalogEntry || !Array.isArray(catalogEntry.versions) || catalogEntry.versions.length === 0) {
        updateFirmwareStatusUI({ latest: "‚Äî", state: "error", message: "Device not found in firmware catalog." });
        updateDownloadControls(null, null);
        setDownloadStatus("Could not match this device to any downloadable firmware.");
        setAutoUpdateAvailability(null, "Could not match this device to any downloadable firmware.");
        return;
      }

      updateDownloadControls(catalogEntry, match.key);

      const latestVersion = catalogEntry.versions[0];
      updateFirmwareStatusUI({ latest: latestVersion || "‚Äî" });

      if (!deviceInfo.VERSION || !latestVersion) {
        updateFirmwareStatusUI({ state: "warn", message: "Device firmware version missing or catalog incomplete." });
        setAutoUpdateAvailability(null, "Device firmware version missing; auto-update disabled.");
        return;
      }

      const comparison = compareVersions(deviceInfo.VERSION, latestVersion);
      if (comparison >= 0) {
        updateFirmwareStatusUI({ state: "ok", message: "Firmware is up to date." });
        setDownloadStatus("Device already runs the latest firmware.");
        setAutoUpdateAvailability(null, "Device already up to date; auto-update disabled.");
      } else {
        const readableName = catalogEntry.name || deviceInfo.NAME || "device";
        updateFirmwareStatusUI({
          state: "warn",
          message: "Update available: install version " + latestVersion + " for " + readableName + ".",
        });
        setDownloadStatus("Download version " + latestVersion + " to update this device.");
        setAutoUpdateAvailability(latestVersion, "Auto-update ready for version " + latestVersion + ".");
      }
    }

    function findCatalogEntry(deviceName) {
      if (!firmwareCatalog) return null;
      const normalizedDevice = normalizeName(deviceName);
      let match = null;
      Object.keys(firmwareCatalog).some((key) => {
        const entry = firmwareCatalog[key];
        if (
          normalizeName(key) === normalizedDevice ||
          normalizeName(entry && entry.name) === normalizedDevice
        ) {
          match = { entry, key };
          return true;
        }
        return false;
      });
      return match;
    }

    function normalizeName(value) {
      if (!value) return "";
      return value.toString().toLowerCase().replace(/\s+/g, "").trim();
    }

    function compareVersions(a, b) {
      const sanitize = (version) =>
        version
          .split(/[.-]/)
          .map((part) => {
            const parsed = parseInt(part, 10);
            return Number.isNaN(parsed) ? 0 : parsed;
          });

      const partsA = sanitize(a || "0");
      const partsB = sanitize(b || "0");
      const maxLen = Math.max(partsA.length, partsB.length);

      for (let i = 0; i < maxLen; i++) {
        const diff = (partsA[i] || 0) - (partsB[i] || 0);
        if (diff !== 0) {
          return diff;
        }
      }
      return 0;
    }

    function updateDownloadControls(entry, key) {
      catalogMatchEntry = entry || null;
      catalogMatchKey = key || null;

      if (!firmwareDownloadEls.select || !firmwareDownloadEls.button) {
        return;
      }

      firmwareDownloadEls.select.innerHTML = "";
      firmwareDownloadEls.select.disabled = true;
      firmwareDownloadEls.button.disabled = true;

      if (!entry || !Array.isArray(entry.versions) || entry.versions.length === 0) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = entry ? "No versions available" : "Unavailable";
        firmwareDownloadEls.select.appendChild(option);
        setDownloadStatus(
          entry
            ? "This device currently has no downloadable firmware packages."
            : "Waiting for firmware catalog match before enabling downloads."
        );
        return;
      }

      entry.versions.forEach((version) => {
        const option = document.createElement("option");
        option.value = version;
        option.textContent = version;
        firmwareDownloadEls.select.appendChild(option);
      });

      if (!key) {
        setDownloadStatus("Matched device but missing catalog key; downloads unavailable.");
        setAutoUpdateAvailability(null, "Matched device but missing catalog key; auto-update unavailable.");
        return;
      }

      firmwareDownloadEls.select.disabled = false;
      firmwareDownloadEls.button.disabled = false;
      setDownloadStatus("Select a version and click download to grab the firmware .zip.");
    }

    function setDownloadStatus(message) {
      if (firmwareDownloadEls.status) {
        firmwareDownloadEls.status.textContent = message;
      }
    }

    function setAutoUpdateStatus(message) {
      if (autoUpdateEls.status) {
        autoUpdateEls.status.textContent = message;
      }
    }

    function refreshAutoUpdateButtonState() {
      if (!autoUpdateEls.button) return;
      if (autoUpdateInProgress || uploadInProgress) {
        autoUpdateEls.button.disabled = true;
      } else {
        autoUpdateEls.button.disabled = !pendingAutoVersion;
      }

      if (pendingAutoVersion) {
        autoUpdateEls.button.textContent = "Download & Install " + pendingAutoVersion;
      } else {
        autoUpdateEls.button.textContent = "Download & Install Latest";
      }
    }

    function setAutoUpdateAvailability(version, message) {
      pendingAutoVersion = version || null;
      if (message) {
        setAutoUpdateStatus(message);
      }
      refreshAutoUpdateButtonState();
    }

    function handleFirmwareDownload() {
      if (!catalogMatchKey || !catalogMatchEntry) {
        setDownloadStatus("Device has not been matched to a firmware catalog entry yet.");
        return;
      }

      if (!firmwareDownloadEls.select) {
        return;
      }

      const selectedVersion = firmwareDownloadEls.select.value;
      if (!selectedVersion) {
        setDownloadStatus("Select a firmware version first.");
        return;
      }

      const downloadUrl =
        firmwareBaseUrl +
        "?device=" +
        encodeURIComponent(catalogMatchKey) +
        "&version=" +
        encodeURIComponent(selectedVersion);

      setDownloadStatus("Opening download for version " + selectedVersion + "‚Ä¶");
      window.open(downloadUrl, "_blank");
      setTimeout(() => {
        setDownloadStatus("If nothing downloaded, enable pop-ups and try again.");
      }, 1200);
    }

    async function handleAutoUpdate() {
      if (autoUpdateInProgress || uploadInProgress) {
        setAutoUpdateStatus("Firmware transfer already in progress.");
        return;
      }

      if (!catalogMatchKey || !catalogMatchEntry) {
        setAutoUpdateStatus("Device has not been matched to a firmware catalog entry yet.");
        return;
      }

      if (typeof JSZip === "undefined") {
        setAutoUpdateStatus("JSZip library failed to load; auto-update unavailable.");
        return;
      }

      const selectedVersion =
        (firmwareDownloadEls.select && firmwareDownloadEls.select.value) || pendingAutoVersion;

      if (!selectedVersion) {
        setAutoUpdateStatus("Select a firmware version first.");
        return;
      }

      const downloadUrl =
        firmwareBaseUrl +
        "?device=" +
        encodeURIComponent(catalogMatchKey) +
        "&version=" +
        encodeURIComponent(selectedVersion);

      try {
        autoUpdateInProgress = true;
        refreshAutoUpdateButtonState();
        setAutoUpdateStatus("Downloading firmware version " + selectedVersion + "‚Ä¶");

        const response = await fetch(downloadUrl, { cache: "no-cache" });
        if (!response.ok) {
          throw new Error("Download failed (" + response.status + ")");
        }

        const arrayBuffer = await response.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);
        const binFiles = zip.file(/\.bin$/i) || [];
        const firmwareEntry =
          binFiles.find((file) => /firmware\.bin$/i.test(file.name)) || binFiles[0];

        if (!firmwareEntry) {
          throw new Error("Downloaded package does not contain a firmware .bin file.");
        }

        setAutoUpdateStatus("Preparing firmware image‚Ä¶");
        const firmwareBlob = await firmwareEntry.async("blob");

        if (typeof uploadFirmwareBlob !== "function") {
          throw new Error("Uploader is not ready yet. Please retry in a moment.");
        }

        setAutoUpdateStatus("Uploading firmware to device‚Ä¶");
        await uploadFirmwareBlob(firmwareBlob, firmwareEntry.name || "firmware.bin", true);
        setAutoUpdateStatus("Auto update uploaded. Device should reboot shortly.");
      } catch (err) {
        console.error("Auto update failed", err);
        setAutoUpdateStatus("Auto update failed: " + err.message);
      } finally {
        autoUpdateInProgress = false;
        refreshAutoUpdateButtonState();
      }
    }

    function connectToServer() {
      connectAttempts += 1;
      const isReconnect = connectAttempts > 1;
      const editorContainer = document.getElementById("editor");
      editorContainer.textContent = "Connecting to server: " + ip + "‚Ä¶";

      const showConfig = true;

      fetch("http://" + ip + "?config=" + (showConfig ? "1" : "0"))
        .then((response) => response.json())
        .then((_data) => {
          data = _data;
          console.log("Config:", data);
          buildStructure();
          initWebSocket();
          if (isReconnect) {
            updateFirmwareStatusUI({ state: "checking", message: "Reconnected. Refreshing firmware status‚Ä¶" });
            fetchDeviceHostInfo();
          }
        })
        .catch((err) => {
          console.error("Error fetching config:", err);
          editorContainer.textContent =
            "Error connecting to server. Retrying‚Ä¶";
          setTimeout(connectToServer, 1500);
        });
    }

    function initWebSocket() {
      // Create native WebSocket
      oscWS = new WebSocket("ws://" + ip);
      oscWS.binaryType = "arraybuffer";

      oscWS.addEventListener("open", function () {
        console.log("WebSocket opened");
      });

      oscWS.addEventListener("close", function () {
        console.log("WebSocket closed, reconnecting‚Ä¶");
        setTimeout(connectToServer, 800);
      });

      oscWS.addEventListener("error", function (error) {
        console.log("WebSocket Error", error);
      });

      oscWS.addEventListener("message", function (event) {
        // Check if it's a text message (JSON for logs)
        if (typeof event.data === 'string') {
          try {
            const jsonMsg = JSON.parse(event.data);
            if (jsonMsg.COMMAND === 'LOG') {
              handleLogMessage(jsonMsg.DATA);
            }
          } catch (e) {
            // Not JSON, ignore
          }
          return;
        }

        // Otherwise, expect binary OSC data, decode with osc-mini:
        const oscMsg = OscMini.unpack(event.data);

        const pid = oscMsg.address.substring(1).replace(/\//g, "-");
        const p = document.getElementById(pid);
        const val =
          oscMsg.args && oscMsg.args[0] ? oscMsg.args[0].value : undefined;

        if (p !== undefined && p !== null && val !== undefined) {
          processParameterFeedback(p, val);
        }
      });
    }

    // ==============================
    // Editor generation
    // ==============================
    function buildStructure() {
      const editorContainer = document.getElementById("editor");
      editorContainer.innerHTML = "";
      generateEditor(data, editorContainer, 0);
    }

    async function generateEditor(node, parentElement, level) {
      const containerDiv = parentElement.appendChild(
        createContainerEditor(node, node.DESCRIPTION, level)
      );

      for (const key in node.CONTENTS) {
        const item = node.CONTENTS[key];

        if (item.TYPE) {
          const paramsContainer = containerDiv.querySelector(".parameters");
          paramsContainer.appendChild(createParameterEditor(item, level + 1));
        } else if (item.CONTENTS) {
          const componentsContainer = containerDiv.querySelector(".components");
          generateEditor(item, componentsContainer, level + 1);
        }
      }
    }

    function createContainerEditor(item, key, level) {
      const itemDiv = document.createElement("div");
      itemDiv.classList.add("component", "level" + level);
      itemDiv.innerHTML =
        '<p class="title">' +
        key +
        '</p><div class="parameters"></div><div class="components"></div>';
      return itemDiv;
    }

    function createParameterEditor(item, level) {
      item.id = item.FULL_PATH.substring(1).replace(/\//g, "-");
      let paramDiv;

      if (item.RANGE != null && item.RANGE[0].VALS != null) {
        paramDiv = createEnumParameterEditor(item, level);
      } else {
        switch (item.TYPE) {
          case "I":
            paramDiv = createTriggerEditor(item, level);
            break;
          case "i":
            paramDiv = createIntParameterEditor(item, level);
            break;
          case "f":
            paramDiv = createFloatParameterEditor(item, level);
            break;
          case "s":
            paramDiv = createStringParameterEditor(item, level);
            break;
          case "b":
          case "T":
          case "F":
            paramDiv = createBoolParameterEditor(item, level);
            break;
          default:
            paramDiv = createDefaultParameterEditor(item, level);
            break;
        }
      }

      if (item.ACCESS === 1) {
        const pMain = paramDiv.querySelector("#" + item.id);
        if (pMain) pMain.disabled = true;
        const pVal = paramDiv.querySelector("#" + item.id + "-value");
        if (pVal) pVal.disabled = true;
      }

      if (item.TAGS !== undefined && item.TAGS.includes("config")) {
        paramDiv.classList.add("config");
        const showConfigCheckbox = document.getElementById("showConfig");
        if (showConfigCheckbox && !showConfigCheckbox.checked) {
          paramDiv.style.display = "none";
        }
      }

      return paramDiv;
    }

    function createTriggerEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      paramDiv.innerHTML =
        '<input type="button" id="' +
        item.id +
        '" value="' +
        item.DESCRIPTION +
        '" onclick=\'sendTrigger("' +
        item.FULL_PATH +
        '")\' />';
      return paramDiv;
    }

    function createIntParameterEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      const range =
        item.RANGE !== undefined
          ? 'min="' +
          item.RANGE[0].MIN +
          '" max="' +
          item.RANGE[0].MAX +
          '"'
          : "";
      paramDiv.innerHTML =
        "<label>" +
        item.DESCRIPTION +
        "</label><input type=\"number\" " +
        range +
        ' id="' +
        item.id +
        '" value="' +
        item.VALUE[0] +
        '" oninput=\'sendParameterValue("' +
        item.FULL_PATH +
        '", "i", this.value)\' />';
      return paramDiv;
    }

    function createFloatParameterEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      const hasRange = item.RANGE != null;
      const range = hasRange
        ? 'min="' +
        item.RANGE[0].MIN +
        '" max="' +
        item.RANGE[0].MAX +
        '"'
        : "";
      const inputType = hasRange ? "range" : "number";
      const rangeText = hasRange
        ? '<input type="text" class="sliderText" id="' +
        item.id +
        '-value" value="' +
        item.VALUE[0].toFixed(3) +
        '">'
        : "";
      const updateRange = hasRange
        ? "this.nextElementSibling.value = parseFloat(this.value).toFixed(3);"
        : "";

      paramDiv.innerHTML =
        "<label>" +
        item.DESCRIPTION +
        "</label><input type=\"" +
        inputType +
        "\" " +
        range +
        ' step="any" id="' +
        item.id +
        '" value="' +
        item.VALUE[0] +
        '" oninput=\'' +
        updateRange +
        'sendParameterValue("' +
        item.FULL_PATH +
        '", "f", this.value)\' />' +
        rangeText;
      return paramDiv;
    }

    function createStringParameterEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      paramDiv.innerHTML =
        "<label>" +
        item.DESCRIPTION +
        '</label><input type="text" id="' +
        item.id +
        '" value="' +
        item.VALUE[0] +
        '" onchange=\'sendParameterValue("' +
        item.FULL_PATH +
        '", "s", this.value)\' />';
      return paramDiv;
    }

    function createBoolParameterEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      const checked = item.VALUE[0] ? "checked" : "";
      paramDiv.innerHTML =
        "<label>" +
        item.DESCRIPTION +
        '</label><input type="checkbox" id="' +
        item.id +
        '" ' +
        checked +
        ' oninput=\'sendParameterValue("' +
        item.FULL_PATH +
        '", "i", this.checked)\' />';

      if (item.DESCRIPTION === "enabled") {
        paramDiv.classList.add("enable-param");
      }

      return paramDiv;
    }

    function createEnumParameterEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      let options = "";
      for (const key in item.RANGE[0].VALS) {
        const value = item.RANGE[0].VALS[key];
        const selected = value === item.VALUE[0] ? "selected" : "";
        options +=
          '<option value="' +
          value +
          '" ' +
          selected +
          ">" +
          value +
          "</option>";
      }
      paramDiv.innerHTML =
        "<label>" +
        item.DESCRIPTION +
        '</label><select id="' +
        item.id +
        '" oninput=\'sendParameterValue("' +
        item.FULL_PATH +
        '", "s", this.value)\'>' +
        options +
        "</select>";
      return paramDiv;
    }

    function createDefaultParameterEditor(item, level) {
      const paramDiv = document.createElement("div");
      paramDiv.classList.add("parameter");
      paramDiv.innerHTML =
        "<label>" +
        item.DESCRIPTION +
        '</label><input type="text" id="' +
        item.id +
        '" value="' +
        item.VALUE[0] +
        '" oninput=\'sendParameterValue("' +
        item.FULL_PATH +
        '", "f", this.value)\' />';
      return paramDiv;
    }

    // ==============================
    // OSC helpers
    // ==============================
    function isWsOpen() {
      return oscWS && oscWS.readyState === WebSocket.OPEN;
    }

    function sendTrigger(fullPath) {
      if (!isWsOpen()) return;
      const msg = { address: fullPath };
      oscWS.send(OscMini.pack(msg));
    }

    function sendParameterValue(fullPath, type, value) {
      if (!isWsOpen()) return;
      const msg = {
        address: fullPath,
        args: [{ type: type, value: value }]
      };
      oscWS.send(OscMini.pack(msg));
    }

    function sendCommand(command) {
      if (!isWsOpen()) return;
      const msg = { address: command };
      oscWS.send(OscMini.pack(msg));
    }

    function restartDevice() {
      sendCommand("/restart");
      setTimeout(() => connectToServer(), 1000);
    }

    function updateShowConfig() {
      const show = document.getElementById("showConfig").checked;
      const configElems = document.querySelectorAll(".parameter.config");
      configElems.forEach((el) => {
        el.style.display = show ? "" : "none";
      });
    }

    function processParameterFeedback(p, val) {
      if (p.type === "checkbox") {
        p.checked = !!val;
      } else {
        p.value = val;
      }
      if (p.type === "range" && p.nextElementSibling) {
        p.nextElementSibling.value = parseFloat(p.value).toFixed(3);
      }
    }

    document
      .getElementById("showConfig")
      .addEventListener("change", updateShowConfig);

    // ==============================
    // Logger Panel
    // ==============================
    let logCount = 0;
    const maxLogs = 500; // Limit to prevent memory issues

    function handleLogMessage(data) {
      const loggerContent = document.getElementById("loggerContent");
      const logEntry = document.createElement("div");
      logEntry.classList.add("log-entry", data.type || "info");

      const timestamp = new Date().toLocaleTimeString();
      logEntry.innerHTML = 
        '<span class="log-time">' + timestamp + '</span>' +
        '<span class="log-source">[' + (data.source || "Unknown") + ']</span>' +
        '<span class="log-message">' + (data.message || "") + '</span>';

      loggerContent.appendChild(logEntry);
      logCount++;
      document.getElementById("logCount").textContent = logCount;

      // Auto-scroll to bottom
      loggerContent.scrollTop = loggerContent.scrollHeight;

      // Limit log entries
      if (logCount > maxLogs) {
        const firstLog = loggerContent.querySelector(".log-entry:not(:first-child)");
        if (firstLog) {
          firstLog.remove();
          logCount--;
        }
      }
    }

    function toggleLogger() {
      const panel = document.getElementById("loggerPanel");
      const isOpen = panel.classList.contains("open");

      if (isOpen) {
        panel.classList.remove("open");
        // Disable sendDebugLogs
        sendParameterValue("/comm/server/sendDebugLogs", "i", 0);
      } else {
        panel.classList.add("open");
        // Enable sendDebugLogs
        sendParameterValue("/comm/server/sendDebugLogs", "i", 1);
      }
    }

    function clearLogs() {
      const loggerContent = document.getElementById("loggerContent");
      loggerContent.innerHTML = '<div class="log-entry info"><span class="log-source">System</span><span class="log-message">Logs cleared.</span></div>';
      logCount = 1;
      document.getElementById("logCount").textContent = logCount;
    }

    document.getElementById("loggerToggle").addEventListener("click", toggleLogger);
    document.getElementById("loggerClose").addEventListener("click", toggleLogger);
    document.getElementById("clearLogs").addEventListener("click", clearLogs);

    // ==============================
    // OTA upload logic (no jQuery)
    // ==============================
    (function setupOtaUploader() {
      const fileInput = document.getElementById("firmware");
      const fileMeta = document.getElementById("fileMeta");
      const uploadBtn = document.getElementById("uploadBtn");
      const uploadBtnLabel = document.getElementById("uploadBtnLabel");
      const uploadSpinner = document.getElementById("uploadSpinner");
      const progressFill = document.getElementById("progressFill");
      const progressLabel = document.getElementById("progressLabel");
      const progressValue = document.getElementById("progressValue");
      const statusText = document.getElementById("statusText");
      const defaultUploadLabel = uploadBtnLabel.textContent;

      let selectedFile = null;

      function formatBytes(bytes) {
        if (bytes === undefined || bytes === null) return "‚Äì";
        const units = ["B", "KB", "MB", "GB"];
        let i = 0;
        let value = bytes;
        while (value >= 1024 && i < units.length - 1) {
          value /= 1024;
          i++;
        }
        return value.toFixed(i === 0 ? 0 : 1) + " " + units[i];
      }

      function setStatus(mode, message) {
        statusText.classList.remove("ok", "error", "warn");
        if (mode) statusText.classList.add(mode);
        statusText.innerHTML =
          "<strong>Status:</strong> " + (message || "idle");
      }

      function setProgress(percent, label) {
        const clamped = Math.max(0, Math.min(100, percent || 0));
        progressFill.style.transform = "scaleX(" + clamped / 100 + ")";
        progressValue.textContent = clamped.toFixed(0) + "%";
        if (label) progressLabel.textContent = label;
      }

      function refreshUploadButtonState() {
        uploadBtn.disabled = uploadInProgress || !selectedFile;
      }

      fileInput.addEventListener("change", () => {
        const file = fileInput.files[0];
        selectedFile = file || null;

        if (!selectedFile) {
          fileMeta.innerHTML =
            '<span class="file-pill muted">No file selected</span>';
          setStatus("", "idle");
          setProgress(0, "Waiting for upload‚Ä¶");
          refreshUploadButtonState();
          return;
        }

        const tooBig = selectedFile.size > 3 * 1024 * 1024; // soft warning

        fileMeta.innerHTML =
          '<span class="file-pill">' +
          selectedFile.name +
          "</span>" +
          '<span class="file-pill ' +
          (tooBig ? "warn" : "") +
          '">' +
          formatBytes(selectedFile.size) +
          "</span>";

        setStatus(
          tooBig ? "warn" : "",
          tooBig
            ? "Large file ‚Äî make sure it matches your partition size."
            : "Ready to upload."
        );
        setProgress(0, "Ready.");
        refreshUploadButtonState();
      });

      async function handleManualUpload() {
        if (!selectedFile || uploadInProgress) return;
        try {
          await performFirmwareUpload(selectedFile, selectedFile.name, false);
        } catch (err) {
          console.warn("Manual upload failed", err);
        }
      }

      uploadBtn.addEventListener("click", handleManualUpload);

      function performFirmwareUpload(fileBlob, filename, fromAuto) {
        return new Promise((resolve, reject) => {
          if (!fileBlob) {
            reject(new Error("No firmware selected."));
            return;
          }

          const finalFilename = "firmware.bin";

          uploadInProgress = true;
          uploadSpinner.style.display = "inline-block";
          uploadBtnLabel.textContent = fromAuto ? "Auto updating‚Ä¶" : "Uploading‚Ä¶";
          setStatus(
            "",
            fromAuto
              ? "Auto update in progress‚Ä¶ do not power off."
              : "Uploading firmware‚Ä¶ do not power off."
          );
          setProgress(fromAuto ? 5 : 2, fromAuto ? "Uploading auto update‚Ä¶" : "Starting upload‚Ä¶");
          refreshUploadButtonState();
          refreshAutoUpdateButtonState();

          const xhr = new XMLHttpRequest();
          xhr.open("POST", "http://" + ip + "/uploadFile", true);

          xhr.upload.onprogress = function (evt) {
            if (evt.lengthComputable) {
              const percent = (evt.loaded / evt.total) * 100;
              setProgress(percent, fromAuto ? "Auto uploading‚Ä¶" : "Uploading‚Ä¶");
            } else {
              setProgress(20, fromAuto ? "Auto uploading‚Ä¶" : "Uploading‚Ä¶");
            }
          };

          xhr.onload = function () {
            const ok = xhr.status >= 200 && xhr.status < 300;
            uploadInProgress = false;
            uploadSpinner.style.display = "none";
            refreshUploadButtonState();
            refreshAutoUpdateButtonState();

            if (ok) {
              setProgress(100, "Upload complete. Rebooting‚Ä¶");
              setStatus(
                "ok",
                fromAuto
                  ? "Auto update uploaded ‚Äî device should reboot shortly."
                  : "Upload successful ‚Äî device should reboot into the new firmware."
              );
              if (fromAuto) {
                uploadBtnLabel.textContent = defaultUploadLabel;
              } else {
                uploadBtnLabel.textContent = "Uploaded";
              }
              resolve();
            } else {
              setProgress(0, "Upload failed.");
              setStatus("error", "Upload failed with status " + xhr.status + ".");
              uploadBtnLabel.textContent = fromAuto ? defaultUploadLabel : "Upload failed";
              reject(new Error("Upload failed with status " + xhr.status));
            }
          };

          xhr.onerror = function () {
            uploadInProgress = false;
            uploadSpinner.style.display = "none";
            setProgress(0, "Network error.");
            setStatus("error", "Network error during upload.");
            uploadBtnLabel.textContent = fromAuto ? defaultUploadLabel : "Upload firmware";
            refreshUploadButtonState();
            refreshAutoUpdateButtonState();
            reject(new Error("Network error during upload."));
          };

          const formData = new FormData();
          const fileForJuiceStyle = new File(
            [fileBlob],
            finalFilename,
            { type: "text/plain" }
          );

          // Field name must match the JUCE uploader handler; do not override Content-Type headers manually.
          formData.append("uploadData", fileForJuiceStyle, finalFilename);
          xhr.send(formData);
        });
      }

      uploadFirmwareBlob = function (blob, filename, fromAuto = false) {
        return performFirmwareUpload(blob, filename, fromAuto);
      };
    })();
  </script>
</body>

</html>